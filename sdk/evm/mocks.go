// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package evm

import (
	"context"
	"math/big"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi/bind/v2"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	mock "github.com/stretchr/testify/mock"
)

// newMock_callableContract creates a new instance of mock_callableContract. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_callableContract(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_callableContract {
	mock := &mock_callableContract{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_callableContract is an autogenerated mock type for the callableContract type
type mock_callableContract struct {
	mock.Mock
}

type mock_callableContract_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_callableContract) EXPECT() *mock_callableContract_Expecter {
	return &mock_callableContract_Expecter{mock: &_m.Mock}
}

// Instance provides a mock function for the type mock_callableContract
func (_mock *mock_callableContract) Instance(backend bind.ContractBackend, addr common.Address) *bind.BoundContract {
	ret := _mock.Called(backend, addr)

	if len(ret) == 0 {
		panic("no return value specified for Instance")
	}

	var r0 *bind.BoundContract
	if returnFunc, ok := ret.Get(0).(func(bind.ContractBackend, common.Address) *bind.BoundContract); ok {
		r0 = returnFunc(backend, addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.BoundContract)
		}
	}
	return r0
}

// mock_callableContract_Instance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Instance'
type mock_callableContract_Instance_Call struct {
	*mock.Call
}

// Instance is a helper method to define mock.On call
//   - backend bind.ContractBackend
//   - addr common.Address
func (_e *mock_callableContract_Expecter) Instance(backend interface{}, addr interface{}) *mock_callableContract_Instance_Call {
	return &mock_callableContract_Instance_Call{Call: _e.mock.On("Instance", backend, addr)}
}

func (_c *mock_callableContract_Instance_Call) Run(run func(backend bind.ContractBackend, addr common.Address)) *mock_callableContract_Instance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 bind.ContractBackend
		if args[0] != nil {
			arg0 = args[0].(bind.ContractBackend)
		}
		var arg1 common.Address
		if args[1] != nil {
			arg1 = args[1].(common.Address)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_callableContract_Instance_Call) Return(boundContract *bind.BoundContract) *mock_callableContract_Instance_Call {
	_c.Call.Return(boundContract)
	return _c
}

func (_c *mock_callableContract_Instance_Call) RunAndReturn(run func(backend bind.ContractBackend, addr common.Address) *bind.BoundContract) *mock_callableContract_Instance_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_rpcClient creates a new instance of mock_rpcClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_rpcClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_rpcClient {
	mock := &mock_rpcClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_rpcClient is an autogenerated mock type for the rpcClient type
type mock_rpcClient struct {
	mock.Mock
}

type mock_rpcClient_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_rpcClient) EXPECT() *mock_rpcClient_Expecter {
	return &mock_rpcClient_Expecter{mock: &_m.Mock}
}

// EstimateGas provides a mock function for the type mock_rpcClient
func (_mock *mock_rpcClient) EstimateGas(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
	ret := _mock.Called(ctx, msg)

	if len(ret) == 0 {
		panic("no return value specified for EstimateGas")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethereum.CallMsg) (uint64, error)); ok {
		return returnFunc(ctx, msg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ethereum.CallMsg) uint64); ok {
		r0 = returnFunc(ctx, msg)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ethereum.CallMsg) error); ok {
		r1 = returnFunc(ctx, msg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_rpcClient_EstimateGas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateGas'
type mock_rpcClient_EstimateGas_Call struct {
	*mock.Call
}

// EstimateGas is a helper method to define mock.On call
//   - ctx context.Context
//   - msg ethereum.CallMsg
func (_e *mock_rpcClient_Expecter) EstimateGas(ctx interface{}, msg interface{}) *mock_rpcClient_EstimateGas_Call {
	return &mock_rpcClient_EstimateGas_Call{Call: _e.mock.On("EstimateGas", ctx, msg)}
}

func (_c *mock_rpcClient_EstimateGas_Call) Run(run func(ctx context.Context, msg ethereum.CallMsg)) *mock_rpcClient_EstimateGas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 ethereum.CallMsg
		if args[1] != nil {
			arg1 = args[1].(ethereum.CallMsg)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_rpcClient_EstimateGas_Call) Return(v uint64, err error) *mock_rpcClient_EstimateGas_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *mock_rpcClient_EstimateGas_Call) RunAndReturn(run func(ctx context.Context, msg ethereum.CallMsg) (uint64, error)) *mock_rpcClient_EstimateGas_Call {
	_c.Call.Return(run)
	return _c
}

// FeeHistory provides a mock function for the type mock_rpcClient
func (_mock *mock_rpcClient) FeeHistory(ctx context.Context, blockCount uint64, lastBlock *big.Int, rewardPercentiles []float64) (*ethereum.FeeHistory, error) {
	ret := _mock.Called(ctx, blockCount, lastBlock, rewardPercentiles)

	if len(ret) == 0 {
		panic("no return value specified for FeeHistory")
	}

	var r0 *ethereum.FeeHistory
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, *big.Int, []float64) (*ethereum.FeeHistory, error)); ok {
		return returnFunc(ctx, blockCount, lastBlock, rewardPercentiles)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, *big.Int, []float64) *ethereum.FeeHistory); ok {
		r0 = returnFunc(ctx, blockCount, lastBlock, rewardPercentiles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ethereum.FeeHistory)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, *big.Int, []float64) error); ok {
		r1 = returnFunc(ctx, blockCount, lastBlock, rewardPercentiles)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_rpcClient_FeeHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FeeHistory'
type mock_rpcClient_FeeHistory_Call struct {
	*mock.Call
}

// FeeHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - blockCount uint64
//   - lastBlock *big.Int
//   - rewardPercentiles []float64
func (_e *mock_rpcClient_Expecter) FeeHistory(ctx interface{}, blockCount interface{}, lastBlock interface{}, rewardPercentiles interface{}) *mock_rpcClient_FeeHistory_Call {
	return &mock_rpcClient_FeeHistory_Call{Call: _e.mock.On("FeeHistory", ctx, blockCount, lastBlock, rewardPercentiles)}
}

func (_c *mock_rpcClient_FeeHistory_Call) Run(run func(ctx context.Context, blockCount uint64, lastBlock *big.Int, rewardPercentiles []float64)) *mock_rpcClient_FeeHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 *big.Int
		if args[2] != nil {
			arg2 = args[2].(*big.Int)
		}
		var arg3 []float64
		if args[3] != nil {
			arg3 = args[3].([]float64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mock_rpcClient_FeeHistory_Call) Return(feeHistory *ethereum.FeeHistory, err error) *mock_rpcClient_FeeHistory_Call {
	_c.Call.Return(feeHistory, err)
	return _c
}

func (_c *mock_rpcClient_FeeHistory_Call) RunAndReturn(run func(ctx context.Context, blockCount uint64, lastBlock *big.Int, rewardPercentiles []float64) (*ethereum.FeeHistory, error)) *mock_rpcClient_FeeHistory_Call {
	_c.Call.Return(run)
	return _c
}

// PendingNonceAt provides a mock function for the type mock_rpcClient
func (_mock *mock_rpcClient) PendingNonceAt(ctx context.Context, account common.Address) (uint64, error) {
	ret := _mock.Called(ctx, account)

	if len(ret) == 0 {
		panic("no return value specified for PendingNonceAt")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, common.Address) (uint64, error)); ok {
		return returnFunc(ctx, account)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, common.Address) uint64); ok {
		r0 = returnFunc(ctx, account)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = returnFunc(ctx, account)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_rpcClient_PendingNonceAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PendingNonceAt'
type mock_rpcClient_PendingNonceAt_Call struct {
	*mock.Call
}

// PendingNonceAt is a helper method to define mock.On call
//   - ctx context.Context
//   - account common.Address
func (_e *mock_rpcClient_Expecter) PendingNonceAt(ctx interface{}, account interface{}) *mock_rpcClient_PendingNonceAt_Call {
	return &mock_rpcClient_PendingNonceAt_Call{Call: _e.mock.On("PendingNonceAt", ctx, account)}
}

func (_c *mock_rpcClient_PendingNonceAt_Call) Run(run func(ctx context.Context, account common.Address)) *mock_rpcClient_PendingNonceAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 common.Address
		if args[1] != nil {
			arg1 = args[1].(common.Address)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_rpcClient_PendingNonceAt_Call) Return(v uint64, err error) *mock_rpcClient_PendingNonceAt_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *mock_rpcClient_PendingNonceAt_Call) RunAndReturn(run func(ctx context.Context, account common.Address) (uint64, error)) *mock_rpcClient_PendingNonceAt_Call {
	_c.Call.Return(run)
	return _c
}

// SendTransaction provides a mock function for the type mock_rpcClient
func (_mock *mock_rpcClient) SendTransaction(ctx context.Context, tx *types.Transaction) error {
	ret := _mock.Called(ctx, tx)

	if len(ret) == 0 {
		panic("no return value specified for SendTransaction")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Transaction) error); ok {
		r0 = returnFunc(ctx, tx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_rpcClient_SendTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendTransaction'
type mock_rpcClient_SendTransaction_Call struct {
	*mock.Call
}

// SendTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - tx *types.Transaction
func (_e *mock_rpcClient_Expecter) SendTransaction(ctx interface{}, tx interface{}) *mock_rpcClient_SendTransaction_Call {
	return &mock_rpcClient_SendTransaction_Call{Call: _e.mock.On("SendTransaction", ctx, tx)}
}

func (_c *mock_rpcClient_SendTransaction_Call) Run(run func(ctx context.Context, tx *types.Transaction)) *mock_rpcClient_SendTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.Transaction
		if args[1] != nil {
			arg1 = args[1].(*types.Transaction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_rpcClient_SendTransaction_Call) Return(err error) *mock_rpcClient_SendTransaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_rpcClient_SendTransaction_Call) RunAndReturn(run func(ctx context.Context, tx *types.Transaction) error) *mock_rpcClient_SendTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SuggestGasTipCap provides a mock function for the type mock_rpcClient
func (_mock *mock_rpcClient) SuggestGasTipCap(ctx context.Context) (*big.Int, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SuggestGasTipCap")
	}

	var r0 *big.Int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_rpcClient_SuggestGasTipCap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SuggestGasTipCap'
type mock_rpcClient_SuggestGasTipCap_Call struct {
	*mock.Call
}

// SuggestGasTipCap is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mock_rpcClient_Expecter) SuggestGasTipCap(ctx interface{}) *mock_rpcClient_SuggestGasTipCap_Call {
	return &mock_rpcClient_SuggestGasTipCap_Call{Call: _e.mock.On("SuggestGasTipCap", ctx)}
}

func (_c *mock_rpcClient_SuggestGasTipCap_Call) Run(run func(ctx context.Context)) *mock_rpcClient_SuggestGasTipCap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_rpcClient_SuggestGasTipCap_Call) Return(intParam *big.Int, err error) *mock_rpcClient_SuggestGasTipCap_Call {
	_c.Call.Return(intParam, err)
	return _c
}

func (_c *mock_rpcClient_SuggestGasTipCap_Call) RunAndReturn(run func(ctx context.Context) (*big.Int, error)) *mock_rpcClient_SuggestGasTipCap_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_rpcClientRaw creates a new instance of mock_rpcClientRaw. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_rpcClientRaw(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_rpcClientRaw {
	mock := &mock_rpcClientRaw{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_rpcClientRaw is an autogenerated mock type for the rpcClientRaw type
type mock_rpcClientRaw struct {
	mock.Mock
}

type mock_rpcClientRaw_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_rpcClientRaw) EXPECT() *mock_rpcClientRaw_Expecter {
	return &mock_rpcClientRaw_Expecter{mock: &_m.Mock}
}

// CallContext provides a mock function for the type mock_rpcClientRaw
func (_mock *mock_rpcClientRaw) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, result, method, args)
	} else {
		tmpRet = _mock.Called(ctx, result, method)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CallContext")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, interface{}, string, ...interface{}) error); ok {
		r0 = returnFunc(ctx, result, method, args...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_rpcClientRaw_CallContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CallContext'
type mock_rpcClientRaw_CallContext_Call struct {
	*mock.Call
}

// CallContext is a helper method to define mock.On call
//   - ctx context.Context
//   - result interface{}
//   - method string
//   - args ...interface{}
func (_e *mock_rpcClientRaw_Expecter) CallContext(ctx interface{}, result interface{}, method interface{}, args ...interface{}) *mock_rpcClientRaw_CallContext_Call {
	return &mock_rpcClientRaw_CallContext_Call{Call: _e.mock.On("CallContext",
		append([]interface{}{ctx, result, method}, args...)...)}
}

func (_c *mock_rpcClientRaw_CallContext_Call) Run(run func(ctx context.Context, result interface{}, method string, args ...interface{})) *mock_rpcClientRaw_CallContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 interface{}
		if args[1] != nil {
			arg1 = args[1].(interface{})
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []interface{}
		var variadicArgs []interface{}
		if len(args) > 3 {
			variadicArgs = args[3].([]interface{})
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *mock_rpcClientRaw_CallContext_Call) Return(err error) *mock_rpcClientRaw_CallContext_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_rpcClientRaw_CallContext_Call) RunAndReturn(run func(ctx context.Context, result interface{}, method string, args ...interface{}) error) *mock_rpcClientRaw_CallContext_Call {
	_c.Call.Return(run)
	return _c
}
